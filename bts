#!/usr/bin/env bash
set -Eeuo pipefail

# Version, checked with bts_require
BTS_VERSION=0.2

#
# Runtime constants
#
BTS_APP_ID=${0##*/}
export BTS_APP_ID=${BTS_APP_ID%.*[Ss][Hh]}
export BTS_APP_DIR="${0%/*}"

#
# Logging
#
# Levels
BTS_LOG_LEVEL_TRACE=7
BTS_LOG_LEVEL_DEBUG=6
BTS_LOG_LEVEL_VERBOSE=5
BTS_LOG_LEVEL_INFO=4
BTS_LOG_LEVEL_NOTICE=3
BTS_LOG_LEVEL_WARNING=2
BTS_LOG_LEVEL_ERROR=1
BTS_LOG_LEVEL_FATAL=0
BTS_DEFAULT_LOG_LEVEL=${BTS_LOG_LEVEL_NOTICE}
BTS_LOG_LEVEL=${BTS_LOG_LEVEL:-${BTS_DEFAULT_LOG_LEVEL}}
#
# Logging backend function
bts_L() {
  echo -e "$(date +"%m/%d %H:%M:%S") ${BTS_APP_ID} $@"
}
export -f bts_L
#
# Logging functions for severity logging
bts_T() {
  [ ${BTS_LOG_LEVEL} -lt ${BTS_LOG_LEVEL_TRACE} ] || bts_L "\033[2;90mtrace\033[0m" "$@"
}
export -f bts_T

bts_D() {
  [ ${BTS_LOG_LEVEL} -lt ${BTS_LOG_LEVEL_DEBUG} ] || bts_L "\033[1;90mdebug\033[0m" "$@"
}
export -f bts_D

bts_V() {
  [ ${BTS_LOG_LEVEL} -lt ${BTS_LOG_LEVEL_VERBOSE} ] || bts_L "\033[3;97mverbo \033[0m" "$@"
}
export -f bts_V

bts_I() {
  [ ${BTS_LOG_LEVEL} -lt ${BTS_LOG_LEVEL_INFO} ] || bts_L "\033[1;97minfo \033[0m" "$@"
}
export -f bts_I

bts_N() {
  [ ${BTS_LOG_LEVEL} -lt ${BTS_LOG_LEVEL_NOTICE} ] || bts_L "\033[1;36mnote \033[0m" "$@"
}
export -f bts_N

bts_W() {
  [ ${BTS_LOG_LEVEL} -lt ${BTS_LOG_LEVEL_WARNING} ] || bts_L "\033[0;35mwarn \033[0m" "$@"
}
export -f bts_W

bts_E() {
  [ ${BTS_LOG_LEVEL} -lt ${BTS_LOG_LEVEL_ERROR} ] || bts_L "\033[0;31mERROR\033[0m" "$@" >&2
}
export -f bts_E

bts_F() {
  local LAST_RC=$?
  local BTS_RC=${BTS_RC:-}
  if [ -z "${BTS_RC}" ]
  then
    [ ${LAST_RC} -eq 0 ] && BTS_RC=255 || BTS_RC=${LAST_RC}
  fi
  local MESSAGE_PREFIX_="("
  if [ "${BTS_STEP_ID:-}" ]; then
    if [ "${BTS_STEP_IS_IN_PROGRESS:-}" ]
    then
      MESSAGE_PREFIX_+="in "
    else
      MESSAGE_PREFIX_+="after "
    fi
    MESSAGE_PREFIX_+="step ${BTS_STEP_ID}"
  fi
  [ ${LAST_RC} -eq 0 ] || MESSAGE_PREFIX_+=" command returned ${LAST_RC}"
  [ "${MESSAGE_PREFIX_}" = "(" ] && MESSAGE_PREFIX_= || MESSAGE_PREFIX_+=") "
  bts_L "\033[1;41;97mFATAL\033[0m ${MESSAGE_PREFIX_}$@" >&2
  exit ${BTS_RC}
}
export -f bts_F

#
# Pre-wrap initialization
# At the moment it's only check that the recipe is provided
#
# Recipe file name can be passed as follows: 
# * As BTS_RECIPE env
#   or
# * As 1st positional argument
[ -z "${BTS_RECIPE:-}" -a $# -gt 0 ] \
  && BTS_RECIPE="$1" && shift

BTS_RECIPE_DEFAULT="${BTS_APP_ID}recipe"
#
# If neither of above provided, defaults will be tried:
# * "${BTS_RECIPE_DEFAULT}" or ".${BTS_RECIPE_DEFAULT}" in current directory
# * "${BTS_RECIPE_DEFAULT}" or ".${BTS_RECIPE_DEFAULT}" in BTS directory "${BTS_APP_DIR}"
#
# Find recipe - internal
#
bts_search_recipe_()
{
  local d_
  for d_ in "$@"
  do
    local r_
    for r_ in "${BTS_RECIPE_DEFAULT}" ".${BTS_RECIPE_DEFAULT}"
    do
      r_="${d_:+${d_}/}${r_}"
      [ -e "${r_}" ] && echo "${r_}" && return
    done
  done
}

#
# If BTS_RECIPE points to directory, we search for recipe file in it
#
[ -d "${BTS_RECIPE}" ] \
  && bts_I "\"${BTS_RECIPE}\" is directory, searching recipe in it.." \
  && BTS_RECIPE_SEARCH_DIR_="${BTS_RECIPE}" \
  && BTS_RECIPE=$(bts_search_recipe_ "${BTS_RECIPE_SEARCH_DIR_}") \
  && [ "${BTS_RECIPE}" ] && bts_I "Found recipe \"${BTS_RECIPE}\"" \
  || true

#
# Last attempt to detect in
#
[ -z "${BTS_RECIPE}" ] \
  && bts_D "Recipe not provided, checking defaults.." \
  && BTS_RECIPE=$(bts_search_recipe_ "" "${PWD}/" "${BTS_APP_DIR}/") \
  && [ "${BTS_RECIPE}" ] && bts_I "Found recipe \"${BTS_RECIPE}\"" \
  || true

[ -z "${BTS_RECIPE}" ] \
  && bts_F "Usage error
Recipe file not specified, default not found.
Please provide recipe file:

* as BTS_RECIPE env var
  or
* as 1st positional argument
  or
* as "${BTS_RECIPE_DEFAULT}" or ".${BTS_RECIPE_DEFAULT}" in current directory
  or
* as "${BTS_RECIPE_DEFAULT}" or ".${BTS_RECIPE_DEFAULT}" in BTS directory ("${BTS_APP_DIR}")
"
#
# Recipe dir might contain patches etc
#
BTS_RECIPE_DIR=${BTS_RECIPE%/*}
BTS_RECIPE_DIR=${BTS_RECIPE_DIR%%/}
[ "${BTS_RECIPE_DIR}" -ef "${BTS_RECIPE}" ] \
  && BTS_RECIPE_DIR=.
#
# Recipe base name used for log file name
#
BTS_JOB_NAME=${BTS_JOB_NAME:-$(sed -Ee 's,[\._\-]?('"${BTS_APP_ID}"'[\._\-]?)?recipe$,,i' <<< "${BTS_RECIPE##*/}")}
[ "${BTS_JOB_NAME}" ] || BTS_JOB_NAME=$(basename "${BTS_RECIPE%/*}")
[ "${BTS_JOB_NAME}" ] || bts_F "Fail to determine job name, please set with BTS_JOB_NAME"
#
# Exec self to self + log
#
BTS_APP_WRAPPED_=${BTS_APP_WRAPPED_:-}
if [ -z "${BTS_APP_WRAPPED_}" ]
then
  exec \
    env \
      BTS_APP_WRAPPED_=1 \
      BTS_RECIPE="${BTS_RECIPE}" \
      bash \
        -Eeuo pipefail \
        -c "\"$0\" \"$@\" 2>&1 | tee -a '${BTS_APP_ID}-${BTS_JOB_NAME}.log'"
  BTS_RC=$? \
    bts_F "\`exec\` returned ${BTS_RC}"
fi
#
# One is OK to continue
#
bts_D "Start pid=$$"
bts_I "Job name ${BTS_JOB_NAME}"
bts_D "recipe '${BTS_RECIPE}', dir '${BTS_RECIPE_DIR}'"

# Doesn't work
#exec 3>&1 4>&2
#trap 'exec 2>&4 1>&3' 0 1 2 3
#exec 1 2>&1 | tee "${BTS_APP_ID}"-$(date +%y%m%d-%H%M%S).log

# NB: OS-specific
#
BTS_ARCH=$(uname -m)
BTS_ARCH_SUFFIX=
[ "${BTS_ARCH}" = "x86_64" -o "${BTS_ARCH}" = "amd64" ] \
  && BTS_ARCH_SUFFIX="64" \
  || BTS_ARCH_SUFFIX=""
export BTS_ARCH_SUFFIX

#
# N CPUs
BTS_NCPUS=$(nproc)
BTS_NJOBS_DEFAULT=$(( ${BTS_NCPUS} / 2 ))
export BTS_NJOBS=${BTS_NJOBS:-${BTS_NJOBS_DEFAULT}}

# Init routines for various platforms

# NB: OS-specific
# Runtime properties
#
# OS Class is win / unix / linux / mac / etc
# OS Family is EL, EL etc
BTS_OS_FAMILY=
BTS_OS_FAMILY_EL="EL"
Platform_EL=
case ${OSTYPE,,} in
msys)
	BTS_OS_FAMILY=msys
	;;
cygwin)
	BTS_OS_FAMILY=cygwin
	;;
linux*)
	if [ -f "/etc/redhat-release" ]
	then
	  export BTS_OS_FAMILY=${BTS_OS_FAMILY_EL}
	  export BTS_OS_GENERATION_=$(perl -pe 's,^\D*(\d+).*,$1,' < /etc/redhat-release)
	  export BTS_OS_FAMILY_GENERATION=${BTS_OS_FAMILY}${BTS_OS_GENERATION_}
		Platform_EL=${BTS_OS_FAMILY_GENERATION}
    bts_D "Detected platform ${BTS_OS_FAMILY_GENERATION}"
	else
		bts_F "Unsupported OS family ${OSTYPE}"
	fi
	;;
*)
	bts_F "Unsupported OS ${OSTYPE}"
	;;
esac

#
# Shortcut functions checking OS family and generation
#
bts_os_is_EL() {
  [ ${BTS_OS_FAMILY} = ${BTS_OS_FAMILY_EL} ]
}
export -f bts_os_is_EL

bts_os_is_EL7() {
  bts_os_is_EL && [ ${BTS_OS_GENERATION_} = 7 ]
}
export -f bts_os_is_EL7

bts_os_is_EL8() {
  bts_os_is_EL && [ ${BTS_OS_GENERATION_} = 8 ]
}
export -f bts_os_is_EL7

#
# `bts_required_version` declares required version and verifies
# that actual version is ok
bts_required_version()
{
  [ $# -eq 1 ] || bts_F '`bts_required_version`: exactly one positional argument expected'
  local user_required_version_="$1"
  # User required BTS version must be less or equal to current BTS version
  [ "${user_required_version_}" \< "${BTS_VERSION}" -o "${user_required_version_}" = "${BTS_VERSION}" ] \
    || \
    bts_F "Recipe needs BTS v${user_required_version_} or later"
}
export -f bts_required_version


# Sets BTS_ROOT and other common vars, creates directory structure
bts_init()
{
  # By default we create BTS_ROOT under "/opt"
  # that can be overridden with BTS_ROOT_PARENT
  local BTS_ROOT_PARENT=${BTS_ROOT_PARENT:-"/opt"}
  # Default BTS_ROOT name is ${BTS_JOB_NAME}[-${BTS_JOB_VERSION}]
  # where BTS_JOB_NAME taken from recipe file name
  # and BTS_JOB_VERSION taken from variable named "${BTS_JOB_NAME^^}_VERSION"
  local BTS_V_JOB_VERSION="${BTS_JOB_NAME^^}_VERSION"
  eval local BTS_JOB_VERSION='$'${BTS_V_JOB_VERSION}
  local BTS_ROOT_DEFAULT_NAME="${BTS_JOB_NAME}${BTS_JOB_VERSION:+-${BTS_JOB_VERSION}}"
  #
  # User may set BTS_ROOT explicitly
	BTS_ROOT=${BTS_ROOT:-}
	# Else user may pass BTS_ROOT as first positional parameter
	[ -z "${BTS_ROOT}" -a $# -gt 0 ] && BTS_ROOT="$1" && shift || true
	# Otherwise one use default
	[ "${BTS_ROOT}" ] || BTS_ROOT="${BTS_ROOT_PARENT%%/}/${BTS_ROOT_DEFAULT_NAME}"
	[ "${BTS_ROOT}" ] || bts_F "BTS_ROOT is not defined"
	export BTS_ROOT
  # Default dir for built programs
	export BTS_BIN_DIR="${BTS_ROOT}/bin"
	[ -d "${BTS_BIN_DIR}" ] || mkdir -p "${BTS_BIN_DIR}"
	# Default dir for built superuser programs
	export BTS_SBIN_DIR="${BTS_ROOT}/sbin"
	[ -d "${BTS_SBIN_DIR}" ] || mkdir -p "${BTS_SBIN_DIR}"
	# Default dir for built libraries
	export BTS_LIB_DIR_BASE_NAME="lib"
	export BTS_LIB_DIR_NAME="${BTS_LIB_DIR_BASE_NAME}${BTS_ARCH_SUFFIX}"
	export BTS_LIB_DIR="${BTS_ROOT}/${BTS_LIB_DIR_NAME}"
	export BTS_GENERIC_LIB_DIR="${BTS_ROOT}/${BTS_LIB_DIR_BASE_NAME}"
	[ -d "${BTS_LIB_DIR}" ] || mkdir -p "${BTS_LIB_DIR}"
	[ "${BTS_GENERIC_LIB_DIR}" = "${BTS_LIB_DIR}" -o -e "${BTS_GENERIC_LIB_DIR}" ] \
	  || \
	  ( cd "${BTS_ROOT}" && ln -svf "${BTS_LIB_DIR_NAME}" "${BTS_LIB_DIR_BASE_NAME}" )

	# Default dir for headers
	export BTS_INCLUDE_DIR="${BTS_ROOT}/include"
	[ -d "${BTS_INCLUDE_DIR}" ] || mkdir -p "${BTS_INCLUDE_DIR}"
	# Top dir for source and build dirs
	local BTS_WORK_PARENT_DIR_="${BTS_ROOT%/*}"
	export BTS_WORK_DIR="${BTS_WORK_PARENT_DIR_%%/}/.${BTS_APP_ID}.${BTS_ROOT##*/}"
	[ -e "${BTS_WORK_DIR}" ] || mkdir -p "${BTS_WORK_DIR}"
	(pushd . >/dev/null 2>&1; cd "${BTS_WORK_DIR}" ; popd >/dev/null 2>&1)
	# Conf dir, now storing only profile
	export BTS_CONF_DIR="${BTS_WORK_DIR}/etc"
	[ -d "${BTS_CONF_DIR}" ] || mkdir -p "${BTS_CONF_DIR}"
  # _Exported_ environment vars for user builds
	export BTS_PROFILE=${BTS_PROFILE:-"${BTS_ROOT}/enable"}
	# _Private_ environment vars for build of toolset
	export BTS_PRIVATE_PROFILE="${BTS_WORK_DIR}/.profile"
	# List of profiles loaded by bts_env
#	export BTS_PROFILE_LIST="${BTS_PROFILE} ${BTS_PRIVATE_PROFILE}"
  BTS_SUDO=
	bts_os_is_EL && [ $(id -u) -ne 0 ] && BTS_SUDO="sudo "
	export BTS_SUDO
	# Directory with extras (e.g. patches)
	export BTS_RECIPE_DIR="${BTS_RECIPE%/*}"
	[ "${BTS_RECIPE_DIR}" ] || BTS_RECIPE_DIR="${PWD}"
cat<<EOF >&2
Toolchain tree defined:
Prefix:        ${BTS_ROOT}
Library path:  ${BTS_LIB_DIR}
Includes path: ${BTS_INCLUDE_DIR}
BTS path:      ${BTS_WORK_DIR}
BTS profile:   ${BTS_PROFILE}
EOF
	#
	BTS_SUDO=${BTS_SUDO:-}
	export BTS_CMAKE_PREFIX_PATH=${BTS_CMAKE_PREFIX_PATH:-}
	#
	TAG=
  ARCHIEVED_DIR=
  BTS_GET_DIR=
  LOCAL_REPO=
  SCHEME=
  # Inform external world  that we're not ready
	touch "${BTS_ROOT}/.disabled"
}
export -f bts_init


bts_end()
{
  BTS_END_LAST_RC=${BTS_END_LAST_RC:-$?}
  BTS_END_CALL_COUNT=$(( ${BTS_END_CALL_COUNT:-0} + 1 ))
#  bts_T "
#  Last RC ${BTS_END_LAST_RC}
#  Step ${BTS_STEP_ID:-}
#  CC ${BTS_END_CALL_COUNT}
#  "
  if [ ${BTS_END_CALL_COUNT} -eq 1 ]
  then
    if [ ${BTS_END_LAST_RC} -eq 0 \
      -a "${BTS_STEP_ID:-}" -a ${BTS_STEP_ID:--1} -gt 0 \
      ]
    then
      cd "${BTS_WORK_DIR}"
      bts_N "Done"
    else
      bts_E "Step '${BTS_STEP_ID:--}' returned ${BTS_END_LAST_RC}"
    fi
  fi

	if [ "${BTS_ROOT:-}" -a -e "${BTS_ROOT:-}" ]
	then
    rm -f "${BTS_ROOT}/.disabled"
    date +%s > "${BTS_ROOT}/.updated"
  fi

  return ${BTS_END_LAST_RC}
}
trap bts_end EXIT ERR


# NB: OS-specific
bts_pkg()
{
	case "${BTS_OS_FAMILY}" in
	${BTS_OS_FAMILY_EL})
	  if bts_os_is_EL8
	  then
		  ${BTS_SUDO} dnf -y "$@"
		elif bts_os_is_EL7
		then
		  ${BTS_SUDO} yum -y "$@"
		else
		  bts_F "Unsupported OS family '${BTS_OS_FAMILY_GENERATION}'"
		fi
		;;
  cygwin)
    if ! command -v apt-cyg >/dev/null 2>&1
    then
      bts_N "apt-cyg missing"
      curl -nOL https://raw.githubusercontent.com/transcode-open/apt-cyg/master/apt-cyg
      if [ ! -d ~/exec ]
      then
        mkdir ~/exec
        export PATH=~/exec:${PATH}
      fi
      install apt-cyg ~/exec
      bts_N "apt-cyg installed as $(command -v apt-cyg)"
    fi
    apt-cyg "$@"
    ;;
	msys)
		local a="$1"
		shift
		case "${a}" in
		[Ii][Nn][Ss][Tt][Aa][Ll][Ll])
			pacman -S --needed --noconfirm "$@"
			;;
		*)
			bts_F "Command '${a}' not supported"
			;;
		esac
		;;
	esac
}
export -f bts_pkg


bts_env()
{
	(
#	  set -x
    for p_ in "${BTS_PROFILE}" "${BTS_PRIVATE_PROFILE}"
    do
	    [ ! -f "${p_}" ] || source "${p_}"
	  done
#	  env | egrep '^\S' | egrep '^BTS|PATH|FLAGS' | sort
	  command "$@"
  )
  local rc_=$?
  : || bts_D "Command:
  \"$@\"
returned ${rc_}
  "
  return ${rc_}
}
export -f bts_env


bts_configure()
{
  local prefix_=${BTS_CONFIGURE_PREFIX:-"${BTS_ROOT}"}
  local libdir_=${BTS_CONFIGURE_LIBDIR:-"${prefix_}/${BTS_LIB_DIR_NAME}"}
  [ "${libdir_}" ] || libdir_="${BTS_LIB_DIR}"
	bts_env ${BTS_CONFIGURE_DIR:-.}/configure --prefix="${prefix_}" --libdir="${libdir_}" "$@"
}
export -f bts_configure


bts_make()
{
	bts_env "${BTS_COMMAND_MAKE:-make}" -j${BTS_NJOBS} "$@"
}
export -f bts_make


# Should be done in `init`
export BTS_DEFAULT_BUILD_TYPE="Release"
bts_cmake()
{
  local GENERATOR_=${BTS_CMAKE_GENERATOR_:-"Ninja Multi-Config"}
  local DASH_G_
  DASH_G_=-G"${GENERATOR_}"
  bts_N "Use '${GENERATOR_}'"
#  bts_D "Command: cmake -G\"${GENERATOR_}\" -DCMAKE_INSTALL_PREFIX=\"${BTS_ROOT}\" -DCMAKE_PREFIX_PATH=\"${BTS_ROOT};${BTS_CMAKE_PREFIX_PATH}\" \"$@\""
  BTS_PROFILE="${BTS_PROFILE}" \
	bts_env cmake \
	  -G"${GENERATOR_}" \
	  -DBUILD_TYPE="${BTS_BUILD_TYPE:-${BTS_DEFAULT_BUILD_TYPE}}" \
	  -DCMAKE_BUILD_TYPE="${BTS_BUILD_TYPE:-${BTS_DEFAULT_BUILD_TYPE}}" \
	  -DCMAKE_INSTALL_PREFIX=${BTS_CMAKE_INSTALL_PREFIX:-"${BTS_ROOT}"} \
	  -DCMAKE_PREFIX_PATH="${BTS_ROOT}${BTS_CMAKE_PREFIX_PATH:+;${BTS_CMAKE_PREFIX_PATH}}" \
	  "$@"
}
export -f bts_cmake


bts_cmake_build_install()
{
  bts_env cmake --build . -j${BTS_NJOBS} --config="${BTS_BUILD_TYPE:-${BTS_DEFAULT_BUILD_TYPE}}" --target install${BTS_CMAKE_INSTALL_TYPE:-"/strip"}
}
export -f bts_cmake_build_install


bts_step()
{
  # `bts_step` opens and closes BTS scopes
  # @param BTS_SCOPE_NAME_ - mandatory, must be non-empty
  # First call opens the scope
  # Second call closes one

  # Check usage
  [ $# -gt 0 ] || bts_F "\`bts_step\`: mandatory argument(s) missing"
  #
  # Scope name is global to enable use in `bts_F
  BTS_SCOPE_NAME_="$@"

  # Ensure that work dir exists
	[ -d "${BTS_WORK_DIR}" ] || mkdir -p "${BTS_WORK_DIR}"
	cd "${BTS_WORK_DIR}"

  # ID identifies current scope with file system entries
  local BTS_SCOPE_ID_=$(perl -pe 's,[^\w\.]+,-,g; s,^\-|\-$,,g' <<< "${BTS_SCOPE_NAME_}")
  local BTS_SCOPE_FLAG_FILE_="${BTS_WORK_DIR}/.${BTS_APP_ID}.${BTS_SCOPE_ID_}"

  # V identifies current scope with shell variables
  local BTS_SCOPE_V_="BTS_SCOPE_V_"$(perl -pe 's,\W+,_,g; s,^_|_$,,g;' <<< "${BTS_SCOPE_ID_}")"_"

	# Evaluate count this step was called
	local BTS_SCOPE_V_C_="${BTS_SCOPE_V_}CALL_C_"
	eval ${BTS_SCOPE_V_C_}="\$(( \${${BTS_SCOPE_V_C_}:-0} + 1 ))"
	eval local BTS_SCOPE_STATUS_="\${${BTS_SCOPE_V_C_}}"

	# Step number
	BTS_STEP_ID=${BTS_STEP_ID:-1}

	bts_T "${BTS_SCOPE_NAME_} (#${BTS_STEP_ID}): status ${BTS_SCOPE_STATUS_}, ${BTS_SCOPE_FLAG_FILE_##*/} "$([ -e "${BTS_SCOPE_FLAG_FILE_}" ] && echo "EXISTS" || echo "MISSING")

  # Check status
	if [ ${BTS_SCOPE_STATUS_} -eq 1 -a -f "${BTS_SCOPE_FLAG_FILE_}" ]
	then
	  bts_I "${BTS_STEP_ID} ${BTS_SCOPE_NAME_}"
	  bts_I "Skip [already done]"
	  BTS_STEP_ID=$(( ${BTS_STEP_ID} + 1 ))
	  return 1
	elif [ ${BTS_SCOPE_STATUS_} -eq 2 ]
	then
		touch "${BTS_SCOPE_FLAG_FILE_}"
		# Global, to enable access from `bts_F` and in similar cases
		BTS_STEP_IS_IN_PROGRESS=
		bts_I "Done"
		BTS_STEP_ID=$(( ${BTS_STEP_ID} + 1 ))
		return 1
	elif [ ${BTS_SCOPE_STATUS_} -ne 1 ]
	then
	  bts_F "logic error: step '${BTS_SCOPE_NAME_}' (#${BTS_STEP_ID}) got status ${BTS_SCOPE_STATUS_}"
	fi

	bts_N "${BTS_STEP_ID} ${BTS_SCOPE_NAME_}"

  # Todo: make below vars local
	TAG=
	ARCHIEVED_DIR=
	BTS_GET_DIR=
	LOCAL_REPO=
	SCHEME=

	BTS_CURRENT_SOURCE_DIR=
	BTS_CURRENT_BUILD_DIR=

  # Global - to enable `bts_F` and similars to distinguish errors in
  # scopes from ones outside of scopes
  BTS_STEP_IS_IN_PROGRESS=1
	return 0
}
export -f bts_step


bts_build_dir()
{
	BTS_CURRENT_SOURCE_DIR="${PWD}"
	BTS_CURRENT_BUILD_DIR="${BTS_WORK_DIR}/${BTS_CURRENT_SOURCE_DIR##*/}.build"
	[ -d "${BTS_CURRENT_BUILD_DIR}" ] || mkdir -p "${BTS_CURRENT_BUILD_DIR}"
	cd "${BTS_CURRENT_BUILD_DIR}"
	bts_D "Changed to ${PWD}"
}
export -f bts_build_dir


bts_untar()
{
  local FILE_="$1"
  shift
  # Exactly one positional parameter accepted
  [ $# -eq 0 ] || bts_F "\`bts_untar\`: unexpected usage \`bts_untar \"${FILE}\" \"$@\"\`"
  local ARGS_=
  local TR_=
  case "${FILE_}" in
  *[Gg][Zz])
    ARGS_="z"
    ;;
  *[Bb][Zz]|*[Bb][Zz]2|*[Bb][Zz][Ii][Pp]|*[Bb][Zz][Ii][Pp]2)
    ARGS_="j"
    ;;
  *[Xx][Zz])
    ARGS_="J"
    ;;
  *[Tt][Aa][Rr])
    ;;
  *)
    bts_F "Don't know how to extract '${FILE_}'"
    ;;
  esac
#  bts_W "BTS_GET_TOP_DIR '${BTS_GET_TOP_DIR:-}'"
  local TOPDIR_EXPECTED_=${BTS_GET_TOP_DIR:-$(sed -Ee 's,\.t(ar\.)?(gz|[bl]z(ip)?2?|xz)$,,' <<< "${FILE_}")}
  #
  # TODO: handle archives with multiple top directories
  # One has `for` here because `$()` returns some trailing garbage one failed to remove
  for TOPDIR_ in $(tar t${ARGS_}f ${FILE_} | head -1 | sed -s 's,/.*,,' || true)
  do
    [ "${TOPDIR_}" == "${TOPDIR_EXPECTED_}" ] || TR_="--transform=s,^${TOPDIR_%%/*},${TOPDIR_EXPECTED_},"
  done
#  bts_T "untar command: bts_env tar x${ARGS_}f \"${FILE_}\" ${TR_}"
  bts_env tar x${ARGS_}f "${FILE_}" ${TR_}
}
export -f bts_untar


bts_unzip()
{
  bts_env unzip "$@"
}
export -f bts_unzip


bts_get()
{
	local url="$1"
	shift
	bts_D "bts_get URL = ${url}"
	# Many URL end with source code archive file
	# In other cases "file" would be repository name
	local file="${url}"
	# Hack against sourceforge /download URLs
	file=${file%/download}
	# Leave only trailing component
	file=${file##*/}
	# For CVS repo passed as separate arg
	local dir
	# bts_extract_dir
	local BTS_EXTRACT_DIR=${BTS_EXTRACT_DIR:-}
	local BTS_NOCD=${BTS_NOCD:-}

  # TODO: rework
	if [ "${SCHEME}" = "git" ] || egrep -iqs '\.(git)$' <<< "${file}"
	then
		dir=$(sed -e 's,\.git$,,i' <<< "${file}")
		local opt_ref_=""
		if [ "${TAG}" ]
		then
		  dir="${dir}-${TAG}"
		  opt_ref_="-b${TAG}"
		fi
		[ -d "${dir}" ] || git clone --depth 1 ${opt_ref_} --recurse-submodules "$@" "${url}" "${dir}"
		cd "${dir}"
#		[ "${TAG}" ] && git checkout tags/"${TAG}"
	elif [ "${SCHEME}" = "svn" ] || egrep -iqs '^svn://' <<< "${url}"
	then
		local SCHEME="svn"
		[ "${LOCAL_REPO}" ] || bts_F "Schema ${SCHEME} requires LOCAL_REPO to be set"
		dir="${LOCAL_REPO}"
		[ -d "${dir}" ] || svn co "${url}" "${LOCAL_REPO}"
		cd "${dir}"
	elif [ "${SCHEME}" = "cvs" ] || egrep -iqs '^cvs:/*' <<< "${url}"
	then
		local SCHEME="cvs"
		local repo="${1:-}"
    shift
		local url_=$(sed -e 's,^cvs:/*,,i' <<< "${url}")
		# Todo: checkout to dir passed with LOCAL_REPO if specified
		[ "${repo}" ] || bts_F "Schema ${SCHEME} requires repository name passed as last arg"
		dir="${repo}"
		local cmd="cvs -z3 -d ${url_} co"
		[ "${TAG}" ] && cmd+=" -r ${TAG}"
		cmd+=" ${repo}"
		[ -d "${dir}" ] || ${cmd}
		cd "${dir}"
	elif [ "${SCHEME}" = "rsync" ] ### Invent scheme for rsync ?? || echo "${url}" | egrep -iqs '^cvs:/*'
  then
    local SCHEME="rsync"
    local url_="${url}"
    dir="${url_##*/}"
    local cmd="rsync -az ${url_}"
    cmd="${cmd} ${repo:-.}"
    [ -z "${BTS_GET_FORCE:-}" -a -d "${dir}" ] || ${cmd}
    cd "${dir}"
	else
	  local archive_type_
	  local extract_fn_
	  if egrep -iqs '\.(tar|t(ar\.)?(gz|bz2?|xz))$' <<< "${file}"
    then
      archive_type_="tar"
      extract_fn_="bts_untar"
      dir=$(echo "${file}" | perl -pe 's,\.(tar|t(ar\.)?(gz|bz2?|xz))$,,i')
      bts_D "File '${file}', expected dir '${dir}'"
    elif egrep -iqs '\.zip$' <<< "${file}"
    then
      archive_type_="zip"
      extract_fn_="bts_unzip"
      dir=$(sed -Ee 's,\.zip$,,i' <<< "${file}")
    else
			bts_F "Unsupported archive ${file}"
		fi
    # Archived directory can be override
    [ "${ARCHIEVED_DIR}" ] \
      && dir="${ARCHIEVED_DIR}"
    # Fetch file
		[ -f "${file}" ] || curl -#nL -o "${file}" "${url}"
    # Extract file
    if [ "${BTS_GET_DIR:-}" ]
    then
      [ -d "${BTS_GET_DIR}" ] || mkdir -p "${BTS_GET_DIR}"
      cd "${BTS_GET_DIR}"
      ${extract_fn_} "${BTS_WORK_DIR}/${file}"
    else
      ${extract_fn_} "${file}"
    fi
    if [ "${BTS_NOCD:-}" ]
    then
      :
    elif [ "${BTS_GET_TOP_DIR:-}" ]
    then
      cd "${BTS_GET_TOP_DIR}"
    elif [ "${BTS_EXTRACT_DIR}" -a -d "${BTS_EXTRACT_DIR}" ]
    then
      cd "${BTS_EXTRACT_DIR}"
    elif [ -d "${dir}" ]
    then
      cd "${dir}"
    fi
	fi
	bts_D "Changed to ${PWD}"
}
export -f bts_get

bts_I "Start"
source "${BTS_RECIPE}"