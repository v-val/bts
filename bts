#!/usr/bin/env bash
set -Eeuo pipefail

BTS_APP_ID=${0##*/}
export BTS_APP_ID=${BTS_APP_ID%.*[Ss][Hh]}
export BTS_APP_DIR="${0%/*}"

#
# Logging
#
# Levels
export BTS_LOG_LEVEL_TRACE=7
export BTS_LOG_LEVEL_DEBUG=6
export BTS_LOG_LEVEL_VERBOSE=5
export BTS_LOG_LEVEL_INFO=4
export BTS_LOG_LEVEL_NOTICE=3
export BTS_LOG_LEVEL_WARNING=2
export BTS_LOG_LEVEL_ERROR=1
export BTS_LOG_LEVEL_FATAL=0
export BTS_DEFAULT_LOG_LEVEL=${BTS_LOG_LEVEL_NOTICE}
export BTS_LOG_LEVEL=${BTS_LOG_LEVEL:-${BTS_DEFAULT_LOG_LEVEL}}
#
# Logging backend function
bts_L() {
  echo -e "$(date +"%m/%d %H:%M:%S.%1N") ${BTS_APP_ID} $@"
}
export -f bts_L

BTS_HAVE_TTY_=
if tty >/dev/null 2>&1
then
    BTS_HAVE_TTY_=1
    if NCOLORS_=$(tput colors) && [ ${NCOLORS_} -gt 2 ]
    then
        BTS_RESET_OUTPUT_STYLE_="\033[0m"
        BTS_OUTPUT_STYLE_TRACE_="\033[2;90m"
        BTS_OUTPUT_STYLE_DEBUG_="\033[1;90m"
        BTS_OUTPUT_STYLE_VERBOSE_="\033[97m"
        BTS_OUTPUT_STYLE_INFO_="\033[1;97m"
        BTS_OUTPUT_STYLE_NOTICE_="\033[1;36m"
        BTS_OUTPUT_STYLE_WARNING_="\033[0;35m"
        BTS_OUTPUT_STYLE_ERROR_="\033[0;31m"
        BTS_OUTPUT_STYLE_FATAL_="\033[1;41;97m"
    fi
fi

#
# Logging functions for severity logging
bts_T() {
  [ ${BTS_LOG_LEVEL} -lt ${BTS_LOG_LEVEL_TRACE} ] || bts_L "${BTS_OUTPUT_STYLE_TRACE_:-}trace${BTS_RESET_OUTPUT_STYLE_:-}" "$@"
}
export -f bts_T

bts_D() {
  [ ${BTS_LOG_LEVEL} -lt ${BTS_LOG_LEVEL_DEBUG} ] || bts_L "${BTS_OUTPUT_STYLE_DEBUG_:-}debug${BTS_RESET_OUTPUT_STYLE_:-}" "$@"
}
export -f bts_D

bts_V() {
  [ ${BTS_LOG_LEVEL} -lt ${BTS_LOG_LEVEL_VERBOSE} ] || bts_L "${BTS_OUTPUT_STYLE_VERBOSE_:-}verb ${BTS_RESET_OUTPUT_STYLE_:-}" "$@"
}
export -f bts_V

bts_I() {
  [ ${BTS_LOG_LEVEL} -lt ${BTS_LOG_LEVEL_INFO} ] || bts_L "${BTS_OUTPUT_STYLE_INFO_:-}info ${BTS_RESET_OUTPUT_STYLE_:-}" "$@"
}
export -f bts_I

bts_N() {
  [ ${BTS_LOG_LEVEL} -lt ${BTS_LOG_LEVEL_NOTICE} ] || bts_L "${BTS_OUTPUT_STYLE_NOTICE_:-}note ${BTS_RESET_OUTPUT_STYLE_:-}" "$@"
}
export -f bts_N

bts_W() {
  [ ${BTS_LOG_LEVEL} -lt ${BTS_LOG_LEVEL_WARNING} ] || bts_L "${BTS_OUTPUT_STYLE_WARNING_:=}warn ${BTS_RESET_OUTPUT_STYLE_:-}" "$@"
}
export -f bts_W

bts_E() {
  [ ${BTS_LOG_LEVEL} -lt ${BTS_LOG_LEVEL_ERROR} ] || bts_L "${BTS_OUTPUT_STYLE_ERROR_:-}ERROR${BTS_RESET_OUTPUT_STYLE_:-}" "$@" >&2
}
export -f bts_E

bts_F() {
    # Code returned by previous command
    local LAST_RC=$?
    # Code that bts will return. Can be set by caller.
    local BTS_RC=${BTS_RC:-}
    if [ -z "${BTS_RC}" ]
    then
        [ ${LAST_RC} -eq 0 ] && BTS_RC=255 || BTS_RC=${LAST_RC}
    fi
    local MESSAGE_PREFIX_="${BASH_SOURCE[1]##*/} L${BASH_LINENO} "
    if [ "${BTS_STEP_ID:-}" ]; then
        MESSAGE_PREFIX_+=" (step ${BTS_STEP_ID}) "
        BTS_STEP_ID=$(( ${BTS_STEP_ID} - 1 ))
    fi
    [ ${LAST_RC} -eq 0 ] || MESSAGE_PREFIX_+=" rc ${LAST_RC}"
    bts_L "${BTS_OUTPUT_STYLE_FATAL_:-}FATAL${BTS_RESET_OUTPUT_STYLE_:-} ${MESSAGE_PREFIX_}$@" >&2
    exit ${BTS_RC}
}
export -f bts_F


# Return true if step entered and not finished yet
bts_step_is_in_progress_() {
    # Step creates BTS_STEP_STARTED_FILE upon start removes when completed successfully
#    "${BUILD_STEP_FILE}"[ -z "${BTS_STEP_STARTED_FILE:-}" ]
    [ "${BTS_STEP_STARTED_FILE:-}" -a -f "${BTS_STEP_STARTED_FILE:-}" ]
}
#export -f bts_step_is_in_progress_


bts_get_timestamp_() {
  date +%s%N
}
export -f bts_get_timestamp_

#
# Auto-set vars, affecting further behaviour
#
# Curl progress flags: '#' if there's tty and '-s' otherwise
[ "${BTS_HAVE_TTY_}" ] \
    && BTS_CURL_PROGRESS_FLAG_='#' \
    || BTS_CURL_PROGRESS_FLAG_='s'

bts_get_duration_() {
  [ $# -eq 2 -a ${1:-1} -gt 0 -a ${2:-1} -gt 0 ] || bts_F "\`bts_get_duration_\`: expected two positive integers, got $@"
  perl -pe '$_ /= 100' <<< $(( ( ${2} - ${1} ) / 10000000 ))
}
export -f bts_get_duration_

#bts_T "Trace data"
#bts_D "Debug info"
#bts_V "Verbose note"
#bts_I "Info message"
#bts_N "Notice fyi"
#bts_W "Warning to check"
#bts_E "Error to fix"
#bts_F "Fatal failure"

#
# Pre-wrap initialization
# At the moment it only checks that the recipe is provided
#
# Recipe file name can be passed as follows: 
# * As BTS_RECIPE env
#   or
# * As 1st positional argument
[ -z "${BTS_RECIPE:-}" -a $# -gt 0 ] \
    && BTS_RECIPE="$1" && shift || :

BTS_RECIPE_DEFAULT="${BTS_APP_ID}recipe"
#
# If neither of above provided, defaults will be tried:
# * "${BTS_RECIPE_DEFAULT}" or ".${BTS_RECIPE_DEFAULT}" in current directory
# * "${BTS_RECIPE_DEFAULT}" or ".${BTS_RECIPE_DEFAULT}" in BTS directory "${BTS_APP_DIR}"
#
# Find recipe - internal
#
bts_search_recipe_()
{
  local d_
  for d_ in "$@"
  do
    local r_
    for r_ in "${BTS_RECIPE_DEFAULT}" ".${BTS_RECIPE_DEFAULT}"
    do
      r_="${d_:+${d_}/}${r_}"
      [ -e "${r_}" ] && echo "${r_}" && return
    done
  done
}

#
# If BTS_RECIPE points to directory, we search for recipe file in it
#
[ -d "${BTS_RECIPE}" ] \
  && bts_I "\"${BTS_RECIPE}\" is directory, searching recipe in it.." \
  && BTS_RECIPE_SEARCH_DIR_="${BTS_RECIPE}" \
  && BTS_RECIPE=$(bts_search_recipe_ "${BTS_RECIPE_SEARCH_DIR_}") \
  && [ "${BTS_RECIPE}" ] && bts_I "Found recipe \"${BTS_RECIPE}\"" \
  || true

#
# Last attempt to detect in
#
[ -z "${BTS_RECIPE}" ] \
  && bts_D "Recipe not provided, checking defaults.." \
  && BTS_RECIPE=$(bts_search_recipe_ "" "${PWD}/" "${BTS_APP_DIR}/") \
  && [ "${BTS_RECIPE}" ] && bts_I "Found recipe \"${BTS_RECIPE}\"" \
  || true

[ -z "${BTS_RECIPE}" ] \
  && bts_F "Usage error
Recipe file not specified, default not found.
Please provide recipe file:

* as BTS_RECIPE env var
  or
* as 1st positional argument
  or
* as "${BTS_RECIPE_DEFAULT}" or ".${BTS_RECIPE_DEFAULT}" in current directory
  or
* as "${BTS_RECIPE_DEFAULT}" or ".${BTS_RECIPE_DEFAULT}" in BTS directory ("${BTS_APP_DIR}")
"
#
# Recipe dir might contain patches etc
#
BTS_RECIPE_DIR=${BTS_RECIPE%/*}
BTS_RECIPE_DIR=${BTS_RECIPE_DIR%%/}
[ "${BTS_RECIPE_DIR}" -ef "${BTS_RECIPE}" ] \
  && BTS_RECIPE_DIR=.
#
# Recipe base name used for log file name
#
BTS_JOB_NAME=${BTS_JOB_NAME:-$(sed -Ee 's,[\._\-]?('"${BTS_APP_ID}"'[\._\-]?)?recipe$,,i' <<< "${BTS_RECIPE##*/}")}
[ "${BTS_JOB_NAME}" ] || BTS_JOB_NAME=$(basename "${BTS_RECIPE%/*}")
[ "${BTS_JOB_NAME}" ] || bts_F "Fail to determine job name, please set with BTS_JOB_NAME"
#
# Exec self to self + log
#
BTS_APP_WRAPPED_=${BTS_APP_WRAPPED_:-}
if [ -z "${BTS_APP_WRAPPED_}" ]
then
  exec \
    env \
      BTS_APP_WRAPPED_=1 \
      BTS_RECIPE="${BTS_RECIPE}" \
      bash \
        -Eeuo pipefail \
        -c "\"$0\" \"$@\" 2>&1 | tee -a '${BTS_APP_ID}-${BTS_JOB_NAME}.log'"
  BTS_RC=$? \
    bts_F "\`exec\` returned ${BTS_RC}"
fi
#
# Script is exec'uting with STDOUT and STDERR redirected to log.
#
################################################################
#
# Count steps
#
BTS_MODE_COUNT_STEPS_ONLY=${BTS_MODE_COUNT_STEPS_ONLY:-}
BTS_STEPS_TOTAL_COUNT=0
BTS_STEP_COUNT_FILE=".${BTS_APP_ID}.${BTS_JOB_NAME}-step-count"
if [ -z "${BTS_MODE_COUNT_STEPS_ONLY:-}" ]
then
    bts_D "Getting step count"
    BTS_APP_WRAPPED_=1 \
    BTS_MODE_COUNT_STEPS_ONLY=1 \
    BTS_RECIPE="${BTS_RECIPE}" \
        bash -Eeuo pipefail -c "$0" "$@"
    if [ -f "${BTS_STEP_COUNT_FILE}" ]
    then
        bts_T "${BTS_STEP_COUNT_FILE} created"
        BTS_STEPS_TOTAL_COUNT=$(cat "${BTS_STEP_COUNT_FILE}")
        rm -f "${BTS_STEP_COUNT_FILE}"
        bts_D "Total step count ${BTS_STEPS_TOTAL_COUNT}"
    else
        bts_F "Fail to count steps in recipe"
    fi
fi
if [ -f "${BTS_STEP_COUNT_FILE}" ]
then
    BTS_STEPS_TOTAL_COUNT=$(cat "${BTS_STEP_COUNT_FILE}")
    rm -f "${BTS_STEP_COUNT_FILE}"
    bts_D "Total step count ${BTS_STEPS_TOTAL_COUNT}"
fi

#
# Return success when is running in "production" mode or failure otherwise
# It depends on BTS_MODE_COUNT_STEPS_ONLY only at the moment
bts_is_in_idle_mode(){
    [ "${BTS_MODE_COUNT_STEPS_ONLY:-}" ]
}
export -f bts_is_in_idle_mode

bts_is_in_work_mode() {
    ! bts_is_in_idle_mode
}
export -f bts_is_in_work_mode

################################################################
#
# Real job starts here.
#
if bts_is_in_work_mode
then
    BTS_JOB_START_TIME_=$(bts_get_timestamp_)
    bts_T "Job start time ${BTS_JOB_START_TIME_}"
    bts_D "Start pid=$$"
    bts_I "Job name ${BTS_JOB_NAME}"
    bts_D "Recipe '${BTS_RECIPE}', dir '${BTS_RECIPE_DIR}'"
fi
#
#
# Counters of processed steps by status
BTS_NSTEPS_PASSED_=0
BTS_NSTEPS_FAILED_=0
BTS_NSTEPS_SKIPPED_=0
BTS_STEP_START_TIME_=

# Doesn't work
#exec 3>&1 4>&2
#trap 'exec 2>&4 1>&3' 0 1 2 3
#exec 1 2>&1 | tee "${BTS_APP_ID}"-$(date +%y%m%d-%H%M%S).log

#
# NB: OS-specific
#
export BTS_ARCH=$(uname -m)
export BTS_ARCH_SUFFIX=$( [[ "${BTS_ARCH}" =~ 64$ ]] && echo "64" || : )
#
# Name of lib dir for libraries built
export BTS_LIB_DIR_BASE_NAME=lib
export BTS_LIB_DIR_NAME=${BTS_LIB_DIR_BASE_NAME}${BTS_ARCH_SUFFIX}

#
# Number of CPUs
#
BTS_NCPUS_=$(nproc)
BTS_NJOBS_DEFAULT_=$(( BTS_NCPUS_ / 2 ))
export BTS_NJOBS=${BTS_NJOBS:-${BTS_NJOBS_DEFAULT_}}

# Init routines for various platforms

# NB: OS-specific
# Runtime properties
#
# OS Class is win / unix / linux / mac / etc
# OS Family is EL, EL etc
BTS_OS_FAMILY=
BTS_OS_FAMILY_EL="EL"
Platform_EL=
case ${OSTYPE,,} in
msys)
	BTS_OS_FAMILY=msys
	;;
cygwin)
	BTS_OS_FAMILY=cygwin
	;;
linux*)
	if [ -f "/etc/redhat-release" ]
	then
        export BTS_OS_FAMILY=${BTS_OS_FAMILY_EL}
        export BTS_OS_GENERATION_=$(perl -pe 's,^\D*(\d+).*,$1,' < /etc/redhat-release)
        export BTS_OS_FAMILY_GENERATION=${BTS_OS_FAMILY}${BTS_OS_GENERATION_}
        Platform_EL=${BTS_OS_FAMILY_GENERATION}
        bts_D "Detected platform ${BTS_OS_FAMILY_GENERATION}"
	else
		bts_F "Unsupported OS family ${OSTYPE}"
	fi
	;;
*)
	bts_F "Unsupported OS ${OSTYPE}"
	;;
esac
#
# Shortcut functions checking OS family and generation
#
bts_os_is_EL() {
  [ ${BTS_OS_FAMILY} = ${BTS_OS_FAMILY_EL} ]
}
export -f bts_os_is_EL

bts_os_is_EL7() {
  bts_os_is_EL && [ ${BTS_OS_GENERATION_} = 7 ]
}
export -f bts_os_is_EL7

bts_os_is_EL8() {
  bts_os_is_EL && [ ${BTS_OS_GENERATION_} = 8 ]
}
export -f bts_os_is_EL7

#
# Next 2 functions merged from .2 without clear intention to use
#
if false
then
#
# `bts_required_version` declares required version and verifies
# that actual version is ok
bts_required_version()
{
  [ $# -eq 1 ] || bts_F '`bts_required_version`: exactly one positional argument expected'
  local user_required_version_="$1"
  # User required BTS version must be less or equal to current BTS version
  [ "${user_required_version_}" \< "${BTS_VERSION}" -o "${user_required_version_}" = "${BTS_VERSION}" ] \
    || \
    bts_F "Recipe needs BTS v${user_required_version_} or later"
}
export -f bts_required_version

#
#
#
bts_compiler_get_version()
{
    [ $# -ne 0 ] || bts_F '`bts_compiler_get_version`: one positional argument required'
    perl -pe 's,^\s*([a-z]+)\D+(\d+(\.\d+)*).*,$1 $2,i' <<< $("${1}" --version | head -1)
}
export -f bts_compiler_get_version
fi

#
# Initialize current step number to empty
#
BTS_STEP_ID=${BTS_STEP_ID:-}


# Sets BTS_ROOT and other common vars, creates directory structure
bts_init()
{
    # By default we create BTS_ROOT under "/opt"
    # that can be overridden with BTS_ROOT_PARENT
    local BTS_ROOT_PARENT=${BTS_ROOT_PARENT:-}
    BTS_USER_=$(id -u)
    if [ -z "${BTS_ROOT_PARENT}" ]
    then
        if [ "${BTS_USER_}" = "root" ]
        then
            BTS_ROOT_PARENT=/opt
        else
            BTS_ROOT_PARENT="${HOME}/opt"
        fi
    fi
    # Default BTS_ROOT name is ${BTS_JOB_NAME}[-${BTS_JOB_VERSION}]
    # where BTS_JOB_NAME taken from recipe file name
    # and BTS_JOB_VERSION taken from variable named "${BTS_JOB_NAME^^}_VERSION"
    local BTS_V_JOB_VERSION=$(sed -Ee 's,\W+,_,g; s,^_+,,' <<< "${BTS_JOB_NAME^^}_VERSION")
    eval local BTS_JOB_VERSION='${'${BTS_V_JOB_VERSION}':-}'
    local BTS_ROOT_DEFAULT_NAME="${BTS_JOB_NAME}${BTS_JOB_VERSION:+-${BTS_JOB_VERSION}}"
    #
    # User may set BTS_ROOT explicitly
	BTS_ROOT=${BTS_ROOT:-}
    # Else user may pass BTS_ROOT as first positional parameter
    [ -z "${BTS_ROOT}" -a $# -gt 0 ] && BTS_ROOT="$1" && shift || true
	# Otherwise one use default
	[ "${BTS_ROOT}" ] || BTS_ROOT="${BTS_ROOT_PARENT%%/}/${BTS_ROOT_DEFAULT_NAME}"
	[ "${BTS_ROOT}" ] || bts_F "BTS_ROOT is not defined"
	export BTS_ROOT
    # Default dir for built programs
	export BTS_BIN_DIR="${BTS_ROOT}/bin"
	# Default dir for built superuser programs
	export BTS_SBIN_DIR="${BTS_ROOT}/sbin"
	# Default dir for built libraries
	export BTS_LIB_DIR_NAME="lib${BTS_ARCH_SUFFIX}"
	export BTS_LIB_DIR="${BTS_ROOT}/${BTS_LIB_DIR_NAME}"
	# Default dir for headers
	export BTS_INCLUDE_DIR="${BTS_ROOT}/include"
	# Top dir for source and build dirs
	export BTS_WORK_DIR=${BTS_WORK_DIR:-"${BTS_ROOT}/.${BTS_APP_ID}"}
	# Create above dirs
	if bts_is_in_work_mode
	then
	    [ -d "${BTS_BIN_DIR}" ]     || mkdir -p "${BTS_BIN_DIR}"
	    [ -d "${BTS_SBIN_DIR}" ]    || mkdir -p "${BTS_SBIN_DIR}"
	    [ -d "${BTS_LIB_DIR}" ]     || mkdir -p "${BTS_LIB_DIR}"
	    [ -d "${BTS_INCLUDE_DIR}" ] || mkdir -p "${BTS_INCLUDE_DIR}"
	    [ -e "${BTS_WORK_DIR}" ]    || mkdir -p "${BTS_WORK_DIR}"
	    (pushd . >/dev/null 2>&1; cd "${BTS_WORK_DIR}" ; popd >/dev/null 2>&1)
	fi
	# Conf dir, now storing only profile
#	export BTS_CONF_DIR="${BTS_WORK_DIR}/etc"
#	[ -d "${BTS_CONF_DIR}" ] || mkdir -p "${BTS_CONF_DIR}"
    # _Exported_ environment vars for user builds
	export BTS_PROFILE=${BTS_PROFILE:-"${BTS_ROOT}/enable"}
	# _Private_ environment vars for build of toolset
	export BTS_PRIVATE_PROFILE="${BTS_WORK_DIR}/.profile"
	# List of profiles loaded by bts_env
#	export BTS_PROFILE_LIST="${BTS_PROFILE} ${BTS_PRIVATE_PROFILE}"
    BTS_SUDO=
	bts_os_is_EL && [ $(id -u) -ne 0 ] && BTS_SUDO="sudo " || :
	export BTS_SUDO
	# Directory with extras (e.g. patches)
	export BTS_RECIPE_DIR="${BTS_RECIPE%/*}"
	[ "${BTS_RECIPE_DIR}" ] || BTS_RECIPE_DIR="${PWD}"
cat<<EOF >&2
BTS tree defined:
Prefix:         ${BTS_ROOT}
Libraries:      ${BTS_LIB_DIR}
Includes:       ${BTS_INCLUDE_DIR}
Work dir:       ${BTS_WORK_DIR}
Enabler script: ${BTS_PROFILE}
EOF
	# [Re]set step id to initial value
	export BTS_STEP_ID=0
	BUILD_STEP_FILE=
	#
	BTS_SUDO=${BTS_SUDO:-}
	export BTS_CMAKE_PREFIX_PATH=${BTS_CMAKE_PREFIX_PATH:-}
	#
	# These vars are used by download / extract helpers
	#
	TAG=
    ARCHIEVED_DIR=
    BTS_GET_DIR=
    LOCAL_REPO=
    SCHEME=
    #
    #  [ ${BTS_LOG_LEVEL} -lt ${BTS_LOG_LEVEL_DEBUG} ] \
    #    || \
    #    env | grep ^BTS | sort
    # Inform external world  that we're not ready
    #
    # TODO: make global constant
    #
    export BTS_FLAG_FILE_DISABLED="${BTS_ROOT}/.disabled"
	bts_is_in_idle_mode || touch "${BTS_FLAG_FILE_DISABLED}"
}
export -f bts_init


#
# Remove [blank-separated] paths from BTS_CLEAN_LIST
#
bts_clean()
{
    # File storing list of files to remove upon successful completion of the job
    BTS_CLEAN_POSTPONED_LIST=${BTS_WORK_DIR}/.${BTS_APP_ID}.__clean-postponed__
    if [ "${BTS_CLEAN_LIST:-}" ]
    then
        if [ "${BTS_CLEAN_POSTPONED:-}" ]
        then
            echo "${BTS_CLEAN_LIST}" >> "${BTS_CLEAN_POSTPONED_LIST}"
            BTS_CLEAN_POSTPONED=
        else
            bts_T "Clean ${BTS_CLEAN_LIST}"
            rm -rf ${BTS_CLEAN_LIST:-}
        fi
        BTS_CLEAN_LIST=
    fi
}
export -f bts_clean


bts_end()
{
    local LAST_RC_=$?
    if [ "${BTS_MODE_COUNT_STEPS_ONLY:-}" ]
    then
        echo ${BTS_STEPS_TOTAL_COUNT} > "${BTS_STEP_COUNT_FILE}"
        return ${LAST_RC_}
    fi
    bts_T "Finished with:
    LAST_RC_    ${LAST_RC_}
    BTS_STEP_ID ${BTS_STEP_ID:-}
    BUILD_STEP_FILE ${BUILD_STEP_FILE:-}
    "
    if [ ${LAST_RC_} -eq 0 \
            -a "${BTS_STEP_ID:-}" -a ${BTS_STEP_ID:--1} -gt 0 \
            -a "${BUILD_STEP_FILE:-}" \
        ]
    then
        cd "${BTS_WORK_DIR}"
        if bts_step_is_in_progress_
        then
            bts_clean
            bts_dump_updated_files
        fi
        if [ -e "${BTS_CLEAN_POSTPONED_LIST}" ]
        then
            if [ ${BTS_STEP_ID:-0} -eq ${BTS_STEPS_TOTAL_COUNT:-0} ]
            then
                bts_N "Remove temp files"
                cat "${BTS_CLEAN_POSTPONED_LIST}" | xargs rm -rf
            else
                bts_N "Keep temp files - completed ${BTS_STEP_ID:-0} steps of ${BTS_STEPS_TOTAL_COUNT:-0}"
            fi
        fi
        bts_N "Done"
    else
        bts_E "Step '${BTS_STEP_ID:--}' returned ${LAST_RC_}"
    fi
    if [ "${BTS_ROOT:-}" -a -e "${BTS_ROOT:-}" ]
    then
        rm -f "${BTS_ROOT}/.disabled"
        date +%s > "${BTS_ROOT}/.updated"
    fi
    return ${LAST_RC_}
}
trap bts_end EXIT ERR


# NB: OS-specific
bts_pkg()
{
    BTS_PKG_REPORT=${BTS_PKG_REPORT:-${BTS_WORK_DIR}/.bts-pkg}
	case "${BTS_OS_FAMILY}" in
	"${BTS_OS_FAMILY_EL}")
        if bts_os_is_EL8
        then
            ${BTS_SUDO:-} dnf -y "$@"
        elif bts_os_is_EL7
        then
            ${BTS_SUDO:-} yum -y "$@"
        else
            bts_F "Unsupported OS family '${BTS_OS_FAMILY_GENERATION}'"
        fi
        # Log package installation
        grep -iqsF "$@" "${BTS_PKG_REPORT}" || echo "$@" >> "${BTS_PKG_REPORT}"
        ;;
    cygwin)
        if ! command -v apt-cyg >/dev/null 2>&1
        then
            bts_N "apt-cyg missing"
            curl -${BTS_CURL_PROGRESS_FLAG_}nLO https://raw.githubusercontent.com/transcode-open/apt-cyg/master/apt-cyg
            if [ ! -d ~/exec ]
            then
                mkdir ~/exec
                export PATH=~/exec:${PATH}
            fi
            install apt-cyg ~/exec
            bts_N "apt-cyg installed as $(command -v apt-cyg)"
        fi
        apt-cyg "$@"
        ;;
	msys)
		local a="$1"
		shift
		case "${a}" in
		[Ii][Nn][Ss][Tt][Aa][Ll][Ll])
			pacman -S --needed --noconfirm "$@"
			;;
		*)
			bts_F "Command '${a}' not supported"
			;;
		esac
		;;
	esac
}
export -f bts_pkg


bts_env()
{
	(
#	    [ -z "${BTS_ENV_SET_X_:-}" ] || set -x
        [ "${BTS_ENV_PUBLIC:-}" -o ! -f "${BTS_PRIVATE_PROFILE}" ] || source "${BTS_PRIVATE_PROFILE}"
        [ ! -f "${BTS_PROFILE}" ] || source "${BTS_PROFILE}"
        [ -z "${BTS_ENV_SHOW_FLAGS:-}" ] || env | egrep '^\w*(PATH|FLAGS)\w*' | sort
        command "$@"
        local RC_=$?
        : || bts_D "Command:
\"$@\"
returned ${RC_}
"
#        [ -z "${BTS_ENV_SET_X_:-}" ] || set +x
        [ ${RC_} -eq 0 ]
#        return ${RC_}
    )
}
export -f bts_env


bts_configure()
{
    local prefix_=${BTS_CONFIGURE_PREFIX:-"${BTS_ROOT}"}
    local libdir_=${BTS_CONFIGURE_LIBDIR:-"${prefix_}/${BTS_LIB_DIR_NAME}"}
    [ "${libdir_}" ] || libdir_="${BTS_LIB_DIR}"
    bts_env "${BTS_CONFIGURE_DIR:-.}/configure" \
            --prefix="${prefix_}" \
            --libdir="${libdir_}" \
            "$@"
}
export -f bts_configure


bts_make()
{
	bts_env "${BTS_COMMAND_MAKE:-make}" -j${BTS_NJOBS} "$@"
}
export -f bts_make


# Should be done in `init`
export BTS_DEFAULT_BUILD_TYPE="Release"
bts_cmake()
{
  local GENERATOR_=${BTS_CMAKE_GENERATOR_:-"Ninja Multi-Config"}
  local DASH_G_=-G"${GENERATOR_}"
  bts_V "Use '${GENERATOR_}'"
#  bts_D "Command: cmake -G\"${GENERATOR_}\" -DCMAKE_INSTALL_PREFIX=\"${BTS_ROOT}\" -DCMAKE_PREFIX_PATH=\"${BTS_ROOT};${BTS_CMAKE_PREFIX_PATH}\" \"$@\""
  BTS_PROFILE="${BTS_PROFILE}" \
	bts_env cmake \
	  -G"${GENERATOR_}" \
	  -DBUILD_TYPE="${BTS_BUILD_TYPE:-${BTS_DEFAULT_BUILD_TYPE}}" \
	  -DCMAKE_BUILD_TYPE="${BTS_BUILD_TYPE:-${BTS_DEFAULT_BUILD_TYPE}}" \
	  -DCMAKE_INSTALL_PREFIX=${BTS_CMAKE_INSTALL_PREFIX:-"${BTS_ROOT}"} \
	  -DCMAKE_PREFIX_PATH="${BTS_ROOT}${BTS_CMAKE_PREFIX_PATH:+;${BTS_CMAKE_PREFIX_PATH}}" \
	  "$@"
}
export -f bts_cmake


bts_cmake_build_install()
{
  bts_env cmake --build . -j${BTS_NJOBS} --config="${BTS_BUILD_TYPE:-${BTS_DEFAULT_BUILD_TYPE}}" --target install${BTS_CMAKE_INSTALL_TYPE:-"/strip"}
}
export -f bts_cmake_build_install

#
# Create file indicating successful completion of the step and
# containing [sorted] list of files created or modified by the step.
# Doesn't make sense if
bts_dump_updated_files()
{
    if bts_step_is_in_progress_
    then
        (
            echo "# ${BTS_STEP_TAG}"
            [ -z "${BTS_STEP_EXTRA_FILES:-}" ] || cat<<EOF
    ${BTS_STEP_EXTRA_FILES}
EOF
            find "${BTS_ROOT}" -cnewer "${BTS_STEP_STARTED_FILE}" \
                    -not -type d -not -path "${BTS_WORK_DIR}/.*" \
                    | sed -Ee "s,^${BTS_ROOT}/*,," | sort
        ) \
                | bzip2 -9  > "${BUILD_STEP_FILE}"
        BTS_STEP_EXTRA_FILES=
        rm -f "${BTS_STEP_STARTED_FILE}"
    else
        bts_F "\`bts_dump_updated_files\` called while step is not in progress"
    fi
}
export -f bts_dump_updated_files


bts_step_make_id_() {
    [ $# -gt 0 ] || bts_F "\`bts_step_make_id_\`: mandatory argument(s) missing"
    perl -pe '
        s,^\s*(install|create)\b\W*,,i ;
        s,[^\w\.]+,-,g ;
        s,^\-|\-$,,g ;
        $_ = lc ;
        ' <<< "$@"
}
export -f bts_step_make_id_


bts_step_make_flag_file_name_() {
    [ $# -gt 0 ] || bts_F "\`bts_step_make_flag_file_name_\`: mandatory argument(s) missing"
    local r_=
    for name_ in "$@"; do
        r_+=${r_:+" "}"${BTS_WORK_DIR}/.${BTS_APP_ID}."$(bts_step_make_id_ "${name_}")
        done
    echo "${r_}"
}
export -f bts_step_make_flag_file_name_


bts_step()
{
    if [ "${BTS_MODE_COUNT_STEPS_ONLY:-}" ]
    then
        BTS_STEPS_TOTAL_COUNT=$(( BTS_STEPS_TOTAL_COUNT + 1 ))
#        bts_T "Counting steps: +1 = ${BTS_STEPS_TOTAL_COUNT}"
        return 1
    fi

	[ -d "${BTS_WORK_DIR}" ] || mkdir -p "${BTS_WORK_DIR}"
	cd "${BTS_WORK_DIR}"
#	echo "  * Changed to ${PWD}"

    #
    # Set previous step as done
    #
	if [ "${BTS_STEP_ID}" -gt 0 -a ! -f "${BUILD_STEP_FILE}" ]
	then
	    # Clean and update metadata only if the step was doing something
		if bts_step_is_in_progress_
		then
		    bts_clean
		    bts_dump_updated_files
		fi
		bts_I "Done"
	fi

	BTS_STEP_ID=$(( ${BTS_STEP_ID} + 1 ))
	local BUILD_STEP_DESC_=${BTS_STEP_DESC:-"$1"}
	[ "${BUILD_STEP_DESC_}" ] || bts_F "Required BTS_STEP_DESC missing!"

    BTS_STEP_TAG=$(
	        perl -pe '
	            s,^\s*(install|create)\b\W*,,i ;
	            s,[^\w\.]+,-,gi; s,^\-|\-$,,g ;
	            $_ = lc ;
	            ' \
	            <<< "${BUILD_STEP_DESC_}"
	        )
	bts_T "step tag ${BTS_STEP_TAG}"
	BUILD_STEP_FILE=".${BTS_APP_ID}.${BTS_STEP_TAG}"

	bts_N "${BTS_STEP_ID} of ${BTS_STEPS_TOTAL_COUNT}: ${BUILD_STEP_DESC_}"
	if [ -f "${BUILD_STEP_FILE}" ]
	then
		bts_I "Skip [already done]"
		return 1
	fi

	TAG=
	ARCHIEVED_DIR=
	BTS_GET_DIR=
	LOCAL_REPO=
	SCHEME=

	BTS_CURRENT_SOURCE_DIR=
	BTS_CURRENT_BUILD_DIR=

	BTS_STEP_STARTED_FILE="${BUILD_STEP_FILE}.in-progress"
	touch -m "${BTS_STEP_STARTED_FILE}"

	return 0
}
export -f bts_step


bts_build_dir()
{
	BTS_CURRENT_SOURCE_DIR="${PWD}"
	if [ "${BTS_BUILD_DIR:-}" ]
	then
	    BTS_CURRENT_BUILD_DIR=${BTS_BUILD_DIR}/.${BTS_APP_ID}${BTS_STEP_TAG:+.${BTS_STEP_TAG}}.${PWD##*/}.build
	else
	    BTS_CURRENT_BUILD_DIR=${BTS_CURRENT_SOURCE_DIR}.build
	fi
	bts_T "build_dir ${BTS_CURRENT_BUILD_DIR}"
	[ -d "${BTS_CURRENT_BUILD_DIR}" ] || mkdir -p "${BTS_CURRENT_BUILD_DIR}"
	cd "${BTS_CURRENT_BUILD_DIR}"
	[ "${BTS_NO_CLEAN:-}" ] || BTS_CLEAN_LIST=${BTS_CLEAN_LIST:+"${BTS_CLEAN_LIST} "}"${PWD}"
	bts_D "In ${PWD}"
}
export -f bts_build_dir


bts_untar()
{
    local FILE_
    [ "$1" = "-" ] && FILE_=${BTS_UNTAR_FILE:-} || FILE_="$1"
    local ARGS_="x"
    if egrep -iqs 'xz$' <<< "${FILE_}" ; then
        ARGS_+="J"
    elif egrep -iqs 'gz$' <<< "${FILE_}" ; then
        ARGS_+="z"
    elif egrep -iqs 'bz2?$' <<< "${FILE_}" ; then
        ARGS_+="j"
    fi
    bts_env tar ${ARGS_}f "$@"
}
export -f bts_untar


bts_unzip()
{
  bts_env unzip "$@"
}
export -f bts_unzip


bts_fetch()
{
    local destination="$1"
    shift
    local source="$1"
    shift
    if [ "${BTS_GET_HELPER:-}" ]
    then
        bts_env curl -${BTS_CURL_PROGRESS_FLAG_}${BTS_FETCH_UNSAFE:+'k'}nLo "${destination}" -H"BTS-Get-URL: ${source}" "${BTS_GET_HELPER:-}"
    else
        bts_env curl -${BTS_CURL_PROGRESS_FLAG_}${BTS_FETCH_UNSAFE:+'k'}nLo "${destination}" "${source}"
    fi
}
export -f bts_fetch


bts_get()
{
	local url="$1"
	shift
	bts_T "get ${url}"
	# Many URL end with source code archive file
	# In other cases "file" would be repository name
	local file="${url}"
	# Hack against sourceforge /download URLs
	file=${file%/download}
	# Leave only trailing component
	file=${file##*/}
	# Drop query string
	file=$(perl -pe 's,[?&].*$,,' <<< "${file}")
	bts_T "get assume result '${file}'"
	# For CVS repo passed as separate arg
	local dir
	# bts_extract_dir
	local BTS_EXTRACT_DIR=${BTS_EXTRACT_DIR:-}
	local BTS_NOCD=${BTS_NOCD:-}

	# Often name of downloaded file can be derived from URL.
	# Unfortunately this is not always the case.
	# To be positive about the name of downloaded file
	# one fetch files to dir with "unique" name.
	local BTS_GET_DIR_=${BTS_GET_DIR:-${BTS_WORK_DIR}}
#	local BTS_GET_LIST_="${BTS_GET_DIR_}/.bts-get.list"
#	local BTS_GET_SOURCE_DIGEST=$(openssl dgst -sha224 <<< "${url}" | cut -f2 -d' ')
#	egrep -iqs "^${BTS_GET_SOURCE_DIGEST}\\b" "${BTS_GET_LIST_}" \
#	        || echo "${BTS_GET_SOURCE_DIGEST} ${url}" >> "${BTS_GET_LIST_}"
	local BTS_GET_CURRENT_DOWNLOAD_DIR=${BTS_GET_DIR_}/.${BTS_APP_ID}${BTS_STEP_TAG:+.${BTS_STEP_TAG}}${file:+.${file}}
	[ -d "${BTS_GET_CURRENT_DOWNLOAD_DIR}" ] || mkdir -p "${BTS_GET_CURRENT_DOWNLOAD_DIR}"
	pushd . >/dev/null 2>&1
	cd "${BTS_GET_CURRENT_DOWNLOAD_DIR}"
	bts_T "get in '${PWD}'"
	[ "${BTS_NO_CLEAN:-}" ] || BTS_CLEAN_LIST=${BTS_CLEAN_LIST:+"${BTS_CLEAN_LIST} "}"${PWD}"

    # TODO: rework
	if [ "${SCHEME}" = "git" ] || egrep -iqs '\.(git)$' <<< "${file}"
	then
		dir=$(sed -e 's,\.git$,,i' <<< "${file}")
		local opt_ref_=
		if [ "${TAG:-}" ]
		then
            dir="${dir}-${TAG}"
            opt_ref_="-b${TAG}"
		fi
		[ -d "${dir}" ] || git clone --depth 1 ${opt_ref_} --recurse-submodules "$@" "${url}" "${dir}"
		cd "${dir}"
	elif [ "${SCHEME}" = "svn" ] || egrep -iqs '^svn://' <<< "${url}"
	then
	    #
	    # Not really supporting SVN
	    #
		local SCHEME="svn"
		[ "${LOCAL_REPO}" ] || bts_F "Schema ${SCHEME} requires LOCAL_REPO to be set"
		dir="${LOCAL_REPO}"
		[ -d "${dir}" ] || svn co "${url}" "${LOCAL_REPO}"
		cd "${dir}"
	elif [ "${SCHEME}" = "cvs" ] || egrep -iqs '^cvs:/*' <<< "${url}"
	then
	    #
	    # Not really supporting CVS
	    #
		local SCHEME="cvs"
		local repo="${1:-}"
        shift
		local url_=$(sed -e 's,^cvs:/*,,i' <<< "${url}")
		# Todo: checkout to dir passed with LOCAL_REPO if specified
		[ "${repo}" ] || bts_F "Schema ${SCHEME} requires repository name passed as last arg"
		dir="${repo}"
		local cmd="cvs -z3 -d ${url_} co"
		[ "${TAG}" ] && cmd+=" -r ${TAG}"
		cmd+=" ${repo}"
		[ -d "${dir}" ] || ${cmd}
		cd "${dir}"
	elif [ "${SCHEME}" = "rsync" ] ### Invent scheme for rsync ?? || echo "${url}" | egrep -iqs '^cvs:/*'
    then
        #
        # Not really supporting RSYNC
        #
        local url_="${url}"
        dir="${url_##*/}"
        local cmd="rsync -az ${url_}"
        cmd="${cmd} ${repo:-.}"
        [ -z "${BTS_GET_FORCE:-}" -a -d "${dir}" ] || ${cmd}
        cd "${dir}"
	else
	    #
	    # Fetch with CURL and extract
	    #
        local archive_type_
        local extract_fn_
        if egrep -iqs '\.(tar|t(ar\.)?(gz|bz2?|xz))$' <<< "${file}"
        then
            archive_type_="tar"
            extract_fn_="bts_untar"
            dir=$(echo "${file}" | perl -pe 's,\.(tar|t(ar\.)?(gz|bz2?|xz))$,,i')
        elif egrep -iqs '\.zip$' <<< "${file}"
        then
            archive_type_="zip"
            extract_fn_="bts_unzip"
            dir=$(sed -Ee 's,\.zip$,,i' <<< "${file}")
        else
			bts_T "get '${file}' doesn't look as archive, fetch without extracting"
		fi
        # Archived directory can be overridden
        [ "${ARCHIEVED_DIR:-}" ] && dir="${ARCHIEVED_DIR}" || :
        # Fetch file
        if [ "${BTS_GET_BACKUP_DIR:-}" ]
        then
            local LOCAL_COPY_="${BTS_GET_BACKUP_DIR}/${file}"
            if [ -e "${LOCAL_COPY_}" ]
            then
                bts_D "Use local copy from \"${BTS_GET_BACKUP_DIR:-}\""
                curl -${BTS_CURL_PROGRESS_FLAG_}O file://"${LOCAL_COPY_}"
            fi
        fi

        if [ ! -e "${file}" ]
        then
            if [ "${BTS_GET_BACKUP_DIR:-}" ]
            then
                [ -e "${BTS_GET_BACKUP_DIR}" ] || mkdir -p "${BTS_GET_BACKUP_DIR}"
                pushd
                cd "${BTS_GET_BACKUP_DIR:-}"
            fi

            ${BTS_FETCH_UNSAFE:-${BTS_GET_UNSAFE:-}} bts_fetch "${file}" "${url}"

            if [ "${BTS_GET_BACKUP_DIR:-}" ]
            then
                popd
                curl -${BTS_CURL_PROGRESS_FLAG_}O file://"${LOCAL_COPY_}"
            fi
        fi

        # Extract file
        if [ "${BTS_GET_DIR:-}" ]
        then
            [ -d "${BTS_GET_DIR}" ] || mkdir -p "${BTS_GET_DIR}"
            cd "${BTS_GET_DIR}"
            ${extract_fn_} "${BTS_WORK_DIR}/${file}"
        elif [ "${extract_fn_:-}" ]
        then
            ${extract_fn_} "${file}"
        fi
        #
        # Downloaded and extracted
        #
        if [ "${BTS_NOCD:-}" ]
        then
            bts_T "get not changing to extracted directory: BTS_NOCD=${BTS_NOCD}"
        elif [ "${BTS_EXTRACT_DIR}" -a -d "${BTS_EXTRACT_DIR}" ]
        then
            cd "${BTS_EXTRACT_DIR}"
	        bts_D "Changed to extracted directory ${PWD}"
        elif [ "${dir:-}" -a -d "${dir:-}" ]
        then
            cd "${dir}"
	        bts_D "Changed to ${PWD}"
	    else
	        bts_T "get can't assume dir to change to, stay in ${PWD}"
        fi
	fi
}
export -f bts_get


bts_is_in_idle_mode || bts_I "Start"
source "${BTS_RECIPE}"